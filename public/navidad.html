<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÑ Blog de Navidad 3D - Engelbert Huber</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700;900&family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,400&family=Mountains+of+Christmas:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --gold: #D4AF37;
            --gold-light: #F4E5B9;
            --crimson: #B22234;
            --forest: #0B3D0B;
            --snow: #FFFAFA;
            --midnight: #0a0a1a;
            --ice-blue: #A5F3FC;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--midnight);
            color: var(--snow);
            overflow-x: hidden;
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="24" font-size="24">‚ùÑÔ∏è</text></svg>'), auto;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .content-layer {
            position: relative;
            z-index: 10;
            pointer-events: none;
        }
        
        .content-layer > * {
            pointer-events: auto;
        }
        
        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
            position: relative;
        }
        
        .hero-title {
            font-family: 'Mountains of Christmas', cursive;
            font-size: clamp(3rem, 12vw, 10rem);
            color: transparent;
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-light) 50%, var(--gold) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 0 0 80px rgba(212, 175, 55, 0.5);
            animation: shimmer 3s ease-in-out infinite;
            letter-spacing: 0.05em;
        }
        
        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .hero-subtitle {
            font-family: 'Cinzel Decorative', serif;
            font-size: clamp(1rem, 3vw, 2rem);
            color: var(--ice-blue);
            margin-top: 1rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            animation: fadeInUp 1.5s ease-out 0.5s both;
        }
        
        .hero-ornament {
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
            margin: 2rem auto;
            position: relative;
        }
        
        .hero-ornament::before {
            content: '‚ùÑ';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: var(--gold);
            animation: spin 8s linear infinite;
        }
        
        @keyframes spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            animation: bounce 2s ease-in-out infinite;
            color: var(--gold-light);
            font-size: 0.9rem;
            letter-spacing: 0.2em;
        }
        
        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            stroke: var(--gold);
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Navigation */
        .nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 1.5rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(10, 10, 26, 0.95), transparent);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .nav.scrolled {
            background: rgba(10, 10, 26, 0.98);
            padding: 1rem 3rem;
        }
        
        .nav-logo {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 1.8rem;
            color: var(--gold);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }
        
        .nav-links a {
            color: var(--snow);
            text-decoration: none;
            font-family: 'Cinzel Decorative', serif;
            font-size: 0.85rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            position: relative;
            padding: 0.5rem 0;
            transition: color 0.3s ease;
        }
        
        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: var(--gold);
            transition: width 0.3s ease;
        }
        
        .nav-links a:hover {
            color: var(--gold);
        }
        
        .nav-links a:hover::after {
            width: 100%;
        }
        
        /* Sections */
        .section {
            min-height: 100vh;
            padding: 6rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }
        
        .section-title {
            font-family: 'Mountains of Christmas', cursive;
            font-size: clamp(2.5rem, 6vw, 5rem);
            text-align: center;
            color: var(--gold);
            margin-bottom: 3rem;
            position: relative;
        }
        
        .section-title::before,
        .section-title::after {
            content: '‚ú¶';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            color: var(--crimson);
            animation: twinkle 2s ease-in-out infinite;
        }
        
        .section-title::before { left: -2rem; }
        .section-title::after { right: -2rem; animation-delay: 1s; }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: translateY(-50%) scale(0.8); }
            50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
        }
        
        /* Article Cards */
        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .article-card {
            background: linear-gradient(145deg, 
                rgba(11, 61, 11, 0.3) 0%, 
                rgba(10, 10, 26, 0.8) 100%);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 20px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        
        .article-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--crimson), var(--gold), var(--forest));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s ease;
        }
        
        .article-card:hover::before {
            transform: scaleX(1);
        }
        
        .article-card:hover {
            transform: translateY(-10px) rotateX(2deg);
            border-color: rgba(212, 175, 55, 0.5);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 60px rgba(212, 175, 55, 0.1),
                inset 0 0 60px rgba(212, 175, 55, 0.05);
        }
        
        .article-card-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .article-card-title {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.4rem;
            color: var(--gold-light);
            margin-bottom: 1rem;
            line-height: 1.3;
        }
        
        .article-card-excerpt {
            font-size: 1.1rem;
            line-height: 1.8;
            color: rgba(255, 250, 250, 0.8);
            margin-bottom: 1.5rem;
        }
        
        .article-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        .article-card-date {
            font-size: 0.9rem;
            color: var(--ice-blue);
            font-style: italic;
        }
        
        .article-card-tag {
            background: linear-gradient(135deg, var(--crimson), #8B0000);
            color: var(--snow);
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        /* About Section */
        .about-content {
            max-width: 900px;
            margin: 0 auto;
            text-align: center;
            padding: 2rem;
        }
        
        .about-avatar {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--forest), var(--crimson));
            margin: 0 auto 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5rem;
            border: 4px solid var(--gold);
            box-shadow: 
                0 0 40px rgba(212, 175, 55, 0.3),
                inset 0 0 40px rgba(0, 0, 0, 0.3);
            animation: float 4s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        .about-text {
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 1.5rem;
            line-height: 1.85;
            color: #ffffff;
            font-weight: 500;
            letter-spacing: 0.01em;
            max-width: 650px;
            margin: 0 auto;
            text-align: center;
            background: rgba(0, 0, 0, 0.75);
            padding: 2rem 2.5rem;
            border-radius: 20px;
            border: 2px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), inset 0 0 60px rgba(212, 175, 55, 0.05);
            backdrop-filter: blur(10px);
        }
        
        .about-text strong {
            color: #ffd700;
            font-weight: 700;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
        }
        
        .about-text .highlight {
            display: block;
            margin-top: 0.5rem;
            color: #a5f3fc;
            font-style: italic;
            font-weight: 500;
            font-size: 1.3rem;
        }
        
        /* Tech Stack */
        .stack-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            max-width: 1200px;
            margin: 2rem auto;
            padding: 2rem;
        }
        
        .stack-item {
            background: rgba(11, 61, 11, 0.2);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 15px;
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.4s ease;
            cursor: default;
        }
        
        .stack-item:hover {
            background: rgba(212, 175, 55, 0.1);
            transform: scale(1.05);
            border-color: var(--gold);
        }
        
        .stack-item-icon {
            font-size: 2rem;
        }
        
        .stack-item-name {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1rem;
            color: var(--snow);
        }
        
        /* Contact Section */
        .contact-form {
            max-width: 600px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-label {
            display: block;
            font-family: 'Cinzel Decorative', serif;
            font-size: 0.9rem;
            color: var(--gold-light);
            margin-bottom: 0.5rem;
            letter-spacing: 0.1em;
        }
        
        .form-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 10px;
            color: var(--snow);
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.1);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }
        
        .form-input::placeholder {
            color: rgba(255, 250, 250, 0.4);
        }
        
        textarea.form-input {
            min-height: 150px;
            resize: vertical;
        }
        
        .submit-btn {
            width: 100%;
            padding: 1.2rem 2rem;
            background: linear-gradient(135deg, var(--crimson), #8B0000);
            border: 2px solid var(--gold);
            border-radius: 10px;
            color: var(--snow);
            font-family: 'Cinzel Decorative', serif;
            font-size: 1rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }
        
        .submit-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .submit-btn:hover::before {
            left: 100%;
        }
        
        .submit-btn:hover {
            background: linear-gradient(135deg, #8B0000, var(--crimson));
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(178, 34, 52, 0.4);
        }
        
        /* Footer */
        .footer {
            padding: 3rem 2rem;
            text-align: center;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
            border-top: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .footer-link {
            color: var(--snow);
            text-decoration: none;
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }
        
        .footer-link:hover {
            color: var(--gold);
            transform: scale(1.2);
        }
        
        .footer-text {
            font-size: 1rem;
            color: rgba(255, 250, 250, 0.6);
        }
        
        .footer-text span {
            color: var(--crimson);
        }
        
        /* Floating decorations */
        .decoration {
            position: fixed;
            pointer-events: none;
            z-index: 5;
            font-size: 2rem;
            opacity: 0.6;
            animation: floatDecor 6s ease-in-out infinite;
        }

        .snowflake {
            position: fixed;
            color: white;
            font-size: 1rem;
            pointer-events: none;
            z-index: 50;
            opacity: 0.8;
            animation: fall linear infinite;
        }

        @keyframes fall {
            0% { transform: translateY(-10vh) rotate(0deg); }
            100% { transform: translateY(110vh) rotate(360deg); }
        }
        
        .decoration:nth-child(1) { top: 20%; left: 5%; animation-delay: 0s; }
        .decoration:nth-child(2) { top: 40%; right: 8%; animation-delay: 1s; }
        .decoration:nth-child(3) { top: 70%; left: 3%; animation-delay: 2s; }
        .decoration:nth-child(4) { top: 85%; right: 5%; animation-delay: 3s; }
        
        @keyframes floatDecor {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(10deg); }
        }
        
        /* Music Toggle */
        .music-toggle {
            position: fixed;
            bottom: 3.5rem;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 3.5rem);
            right: 1rem;
            z-index: 100;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--crimson), #8B0000);
            border: 2px solid var(--gold);
            color: var(--snow);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .music-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 30px rgba(212, 175, 55, 0.4);
        }
        
        .music-toggle.playing {
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(212, 175, 55, 0); }
        }
        
        /* Loading Screen */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--midnight);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }
        
        .loader.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loader-tree {
            font-size: 5rem;
            animation: treePulse 1.5s ease-in-out infinite;
        }
        
        @keyframes treePulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5); }
        }
        
        .loader-text {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            margin-top: 1rem;
            animation: fadeInOut 1.5s ease-in-out infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .nav {
                padding: 1rem 1.5rem;
            }
            
            .nav-links {
                display: none;
            }
            
            .articles-grid {
                grid-template-columns: 1fr;
            }
            
            .section-title::before,
            .section-title::after {
                display: none;
            }
            
            .decoration {
                display: none;
            }
            
            .about-content {
                padding: 1rem;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .about-avatar {
                margin: 0 auto 1.5rem auto !important;
                display: block !important;
            }
            
            .about-text {
                font-size: 1.2rem;
                padding: 1.5rem;
                margin: 0 auto;
                max-width: 95%;
            }
            
            .about-text .highlight {
                font-size: 1.1rem;
            }
        }
        
        /* Article Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(145deg, rgba(11, 61, 11, 0.95), rgba(10, 10, 26, 0.98));
            border: 2px solid var(--gold);
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 3rem;
            position: relative;
            animation: modalIn 0.5s ease;
        }
        
        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(50px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        .modal-close {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            color: var(--gold);
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .modal-close:hover {
            transform: rotate(90deg);
            color: var(--crimson);
        }
        
        .modal-title {
            font-family: 'Cinzel Decorative', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
            padding-right: 3rem;
        }
        
        .modal-body {
            font-size: 1.2rem;
            line-height: 2;
            color: rgba(255, 250, 250, 0.9);
        }
        
        .modal-body p {
            margin-bottom: 1.5rem;
        }
        
        .modal-body h2 {
            font-family: 'Cinzel Decorative', serif;
            color: var(--gold-light);
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
        }
        
        /* Snow Canvas Overlay Info */
        .info-panel {
            position: fixed;
            top: 50%;
            left: 2rem;
            transform: translateY(-50%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .info-item {
            background: rgba(10, 10, 26, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 10px;
            padding: 0.8rem 1.2rem;
            font-size: 0.85rem;
            color: var(--ice-blue);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        
        .info-item:hover {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.1);
            transform: translateX(5px);
        }
        
        .info-item.active {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }
        
        .info-item-icon {
            margin-right: 0.5rem;
        }
        
        /* Snow mode selector */
        .snow-modes {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-left: 1rem;
        }
        
        .snow-modes.visible {
            display: flex;
        }
        
        .snow-mode-btn {
            background: rgba(10, 10, 26, 0.9);
            border: 1px solid rgba(165, 243, 252, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            color: var(--snow);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .snow-mode-btn:hover {
            border-color: var(--ice-blue);
            background: rgba(165, 243, 252, 0.1);
        }
        
        .snow-mode-btn.active {
            border-color: var(--ice-blue);
            background: rgba(165, 243, 252, 0.2);
            color: var(--ice-blue);
        }
        
        /* Tree focus mode */
        .tree-focus-active .content-layer {
            opacity: 0.1;
            pointer-events: none;
        }
        
        .tree-focus-active .info-panel {
            opacity: 1;
        }
        
        .tree-focus-active .nav {
            opacity: 0.3;
        }
        
        /* Tree controls */
        .tree-controls {
            display: none;
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background: rgba(10, 10, 26, 0.95);
            border: 2px solid var(--gold);
            border-radius: 20px;
            padding: 1.5rem 2rem;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .tree-controls.visible {
            display: block;
            animation: slideUp 0.5s ease;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        .tree-controls-title {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 1.5rem;
            color: var(--gold);
            margin-bottom: 1rem;
        }
        
        .tree-controls-hint {
            font-size: 0.9rem;
            color: var(--ice-blue);
            margin-bottom: 1rem;
        }
        
        .tree-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tree-btn {
            background: linear-gradient(135deg, var(--forest), #0d4f0d);
            border: 1px solid var(--gold);
            border-radius: 10px;
            padding: 0.8rem 1.2rem;
            color: var(--snow);
            font-family: 'Cinzel Decorative', serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tree-btn:hover {
            background: linear-gradient(135deg, #0d4f0d, var(--forest));
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.3);
        }
        
        .tree-btn.exit-btn {
            background: linear-gradient(135deg, var(--crimson), #8B0000);
        }
        
        .tree-btn.exit-btn:hover {
            background: linear-gradient(135deg, #8B0000, var(--crimson));
        }
        
        .mobile-tree-btn {
            display: none;
        }
        
        @media (max-width: 1024px) {
            .info-panel {
                display: none;
            }
            
            .mobile-tree-btn {
                display: flex;
                position: fixed;
                bottom: 3.5rem;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 3.5rem);
                left: 1rem;
                transform: none;
                z-index: 150;
                background: rgba(10, 10, 26, 0.9);
                border: 2px solid var(--gold);
                color: var(--gold);
                padding: 0.8rem 1.5rem;
                border-radius: 25px;
                font-family: 'Cinzel Decorative', serif;
                font-size: 1rem;
                cursor: pointer;
                gap: 0.5rem;
                align-items: center;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            }
            
            .mobile-tree-btn:active {
                transform: scale(0.95);
                background: rgba(212, 175, 55, 0.2);
            }
            
            .tree-focus-active .mobile-tree-btn {
                display: none;
            }
            
            .tree-controls {
                top: auto;
                bottom: 1.5rem;
                left: 50%;
                transform: translateX(-50%);
                padding: 0.6rem 1rem;
                max-width: 95vw;
                border-radius: 12px;
                background: rgba(10, 10, 26, 0.9);
            }
            
            .tree-controls-title {
                font-size: 1rem;
                margin-bottom: 0.3rem;
            }
            
            .tree-controls-hint {
                display: none;
            }
            
            .tree-buttons {
                gap: 0.4rem;
            }
            
            .tree-btn {
                padding: 0.5rem 0.7rem;
                font-size: 0.7rem;
                border-radius: 8px;
            }
            
            /* Art√≠culos colapsables en m√≥vil */
            .article-card.mobile-hidden-article {
                display: none;
            }
            
            .article-card.mobile-hidden-article.show {
                display: block;
            }
            
            .show-more-btn {
                display: block;
                width: 100%;
                margin-top: 1.5rem;
                padding: 1rem 2rem;
                background: linear-gradient(135deg, var(--forest), #0d4f0d);
                border: 2px solid var(--gold);
                border-radius: 15px;
                color: var(--gold);
                font-family: 'Cinzel Decorative', serif;
                font-size: 1rem;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            
            .show-more-btn:hover {
                background: linear-gradient(135deg, #0d4f0d, var(--forest));
                transform: scale(1.02);
            }
        }
        
        @media (min-width: 1025px) {
            .show-more-btn {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .tree-controls {
                padding: 0.5rem 0.6rem;
                bottom: 1rem;
            }
            
            .tree-controls-title {
                font-size: 0.9rem;
                margin-bottom: 0.25rem;
            }
            
            .tree-btn {
                padding: 0.4rem 0.5rem;
                font-size: 0.65rem;
            }
        }
        
        /* Visitor Counter */
        .visitor-counter {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 100;
            background: rgba(10, 10, 26, 0.85);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 8px;
            padding: 0.4rem 0.7rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            backdrop-filter: blur(8px);
            font-family: 'Cinzel Decorative', serif;
            font-size: 0.7rem;
            color: var(--ice-blue);
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .visitor-counter:hover {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.1);
            transform: scale(1.05);
        }
        
        .visitor-counter-icon {
            font-size: 0.85rem;
        }
        
        .visitor-counter-number {
            color: var(--gold);
            font-weight: 700;
            font-size: 0.8rem;
            text-shadow: 0 0 8px rgba(212, 175, 55, 0.5);
        }
        
        @media (max-width: 1024px) {
            .visitor-counter {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 0.8rem);
                left: 0.8rem;
                padding: 0.35rem 0.6rem;
                font-size: 0.65rem;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loader" id="loader">
        <div class="loader-tree">üéÑ</div>
        <div class="loader-text">Preparando la magia navide√±a...</div>
    </div>

    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Floating Decorations -->
    <div class="decoration">üéÅ</div>
    <div class="decoration">‚≠ê</div>
    <div class="decoration">üîî</div>
    <div class="decoration">üéÖ</div>
    
    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-item" id="treeToggle" onclick="toggleTreeFocus()">
            <span class="info-item-icon">üéÑ</span> √Årbol interactivo
        </div>
        <div class="info-item" id="snowToggle" onclick="toggleSnowModes()">
            <span class="info-item-icon">‚ùÑÔ∏è</span> Nieve real 3D
        </div>
        <div class="snow-modes" id="snowModes">
            <button class="snow-mode-btn" onclick="setSnowMode(event, 'slow')">üå®Ô∏è Nieve suave</button>
            <button class="snow-mode-btn active" onclick="setSnowMode(event, 'normal')">‚ùÑÔ∏è Nieve normal</button>
            <button class="snow-mode-btn" onclick="setSnowMode(event, 'storm')">üå™Ô∏è Tormenta de nieve</button>
        </div>
    </div>
    
    <!-- Mobile Tree Button (visible only on mobile when not in tree focus) -->
    <button class="mobile-tree-btn" onclick="toggleTreeFocus()">üéÑ √Årbol Interactivo</button>
    
    <!-- Tree Controls (visible when tree is focused) -->
    <div class="tree-controls" id="treeControls">
        <h3 class="tree-controls-title">üéÑ Control del √Årbol</h3>
        <p class="tree-controls-hint">Usa el mouse para rotar ‚Ä¢ Scroll para zoom</p>
        <div class="tree-buttons">
            <button class="tree-btn" onclick="spinTree()">üîÑ Girar</button>
            <button class="tree-btn" id="sparkleBtn">‚ú® Brillar</button>
            <button class="tree-btn" onclick="changeTreeColors()">üé® Colores</button>
            <button class="tree-btn" onclick="addOrnament()">üéÅ + Adorno</button>
            <button class="tree-btn exit-btn" onclick="exitTreeFocus()">‚ùå Salir</button>
        </div>
    </div>
    
    <!-- Navigation -->
    <nav class="nav" id="nav">
        <a href="#" class="nav-logo">üéÑ Engelbert</a>
        <ul class="nav-links">
            <li><a href="#home">Inicio</a></li>
            <li><a href="#articles">Art√≠culos</a></li>
            <li><a href="#about">Sobre M√≠</a></li>
            <li><a href="#stack">Tech Stack</a></li>
            <li><a href="#contact">Contacto</a></li>
        </ul>
    </nav>
    
    <!-- Content -->
    <div class="content-layer">
        <!-- Hero Section -->
        <section class="hero section" id="home">
            <h1 class="hero-title">Feliz Navidad</h1>
            <p class="hero-subtitle">Blog de Engelbert Huber</p>
            <div class="hero-ornament"></div>
            <div class="scroll-indicator">
                <span>Descubre m√°s</span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
                </svg>
            </div>
        </section>
        
        <!-- Articles Section -->
        <section class="section" id="articles">
            <h2 class="section-title">Art√≠culos Destacados</h2>
            <div class="articles-grid">
                <article class="article-card" onclick="openModal('rag')">
                    <span class="article-card-icon">ü§ñ</span>
                    <h3 class="article-card-title">RAG: La Revoluci√≥n de la IA Generativa</h3>
                    <p class="article-card-excerpt">La Generaci√≥n Aumentada por Recuperaci√≥n est√° transformando c√≥mo los modelos de lenguaje acceden y utilizan informaci√≥n actualizada...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">15 Septiembre, 2025</span>
                        <span class="article-card-tag">IA</span>
                    </div>
                </article>
                
                <article class="article-card" onclick="openModal('ai')">
                    <span class="article-card-icon">üß†</span>
                    <h3 class="article-card-title">El Futuro de la Inteligencia Artificial</h3>
                    <p class="article-card-excerpt">Exploramos las tendencias m√°s importantes que est√°n moldeando el futuro de la IA y c√≥mo impactar√°n nuestras vidas...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">20 Octubre, 2025</span>
                        <span class="article-card-tag">Tecnolog√≠a</span>
                    </div>
                </article>
                
                <article class="article-card mobile-hidden-article" onclick="openModal('christmas')">
                    <span class="article-card-icon">üéÑ</span>
                    <h3 class="article-card-title">IA y la Magia de la Navidad</h3>
                    <p class="article-card-excerpt">C√≥mo la inteligencia artificial est√° revolucionando las experiencias navide√±as, desde recomendaciones de regalos hasta decoraciones personalizadas...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">25 Diciembre, 2025</span>
                        <span class="article-card-tag">Navidad</span>
                    </div>
                </article>
                
                <article class="article-card mobile-hidden-article" onclick="openModal('peru')">
                    <span class="article-card-icon">üáµüá™</span>
                    <h3 class="article-card-title">Tecnolog√≠a en Per√∫: Un An√°lisis</h3>
                    <p class="article-card-excerpt">El panorama tecnol√≥gico peruano est√° evolucionando r√°pidamente. Analizamos las oportunidades y desaf√≠os del ecosistema tech local...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">10 Noviembre, 2025</span>
                        <span class="article-card-tag">Per√∫</span>
                    </div>
                </article>
                
                <article class="article-card mobile-hidden-article" onclick="openModal('vibecoding')">
                    <span class="article-card-icon">‚ú®</span>
                    <h3 class="article-card-title">Vibecoding: El Nuevo Paradigma</h3>
                    <p class="article-card-excerpt">Una nueva forma de programar est√° emergiendo donde la intuici√≥n y la IA trabajan juntas para crear c√≥digo de manera m√°s natural...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">5 Diciembre, 2025</span>
                        <span class="article-card-tag">Desarrollo</span>
                    </div>
                </article>
                
                <article class="article-card mobile-hidden-article" onclick="openModal('ml')">
                    <span class="article-card-icon">üìä</span>
                    <h3 class="article-card-title">Machine Learning desde Cero</h3>
                    <p class="article-card-excerpt">Mi experiencia entrenando un modelo GPT-2 desde cero con recursos limitados. Una aventura de aprendizaje y descubrimiento...</p>
                    <div class="article-card-meta">
                        <span class="article-card-date">18 Noviembre, 2025</span>
                        <span class="article-card-tag">ML</span>
                    </div>
                </article>
                
                <button class="show-more-btn" id="showMoreBtn" onclick="toggleArticles()">
                    Ver m√°s art√≠culos ‚ú®
                </button>
            </div>
        </section>
        
        <!-- About Section -->
        <section class="section" id="about">
            <h2 class="section-title">Sobre M√≠</h2>
            <div class="about-content">
                <img src="foto.png" class="about-avatar" alt="Engelbert Huber" style="width: 200px; height: 200px; border-radius: 50%; object-fit: cover; border: 3px solid #ffd700;">
                <p class="about-text">
                    Soy <strong>Engelbert Huber</strong>, vibecoder autodidacta desde Lima. Sin t√≠tulo en tech, pero entreno mis propios modelos de IA y construyo lo que imagino.
                    <br><br>
                    Creo que la tecnolog√≠a debe <strong>empoderar</strong>, no excluir ‚Äîpor eso traduzco lo complejo en accesible.
                    <br><br>
                    Pap√° de Sophie. <span class="highlight">Las barreras m√°s duras ya no son t√©cnicas, son mentales.</span>
                </p>
            </div>
        </section>
        
        <!-- Tech Stack Section -->
        <section class="section" id="stack">
            <h2 class="section-title">Mi Tech Stack</h2>
            <div class="stack-container">
                <div class="stack-item">
                    <span class="stack-item-icon">ü§ñ</span>
                    <span class="stack-item-name">Claude AI</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üí¨</span>
                    <span class="stack-item-name">ChatGPT</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üíé</span>
                    <span class="stack-item-name">Gemini</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üé®</span>
                    <span class="stack-item-name">Midjourney</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üé¨</span>
                    <span class="stack-item-name">Kling</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üîä</span>
                    <span class="stack-item-name">ElevenLabs</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">‚ö°</span>
                    <span class="stack-item-name">Cursor</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üåê</span>
                    <span class="stack-item-name">Next.js</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üî∑</span>
                    <span class="stack-item-name">TypeScript</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üéØ</span>
                    <span class="stack-item-name">Three.js</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">ü§ó</span>
                    <span class="stack-item-name">Hugging Face</span>
                </div>
                <div class="stack-item">
                    <span class="stack-item-icon">üîó</span>
                    <span class="stack-item-name">LangChain</span>
                </div>
            </div>
        </section>
        
        <!-- Contact Section -->
        <section class="section" id="contact">
            <h2 class="section-title">Cont√°ctame</h2>
            <form class="contact-form" onsubmit="handleSubmit(event)">
                <div class="form-group">
                    <label class="form-label">Nombre</label>
                    <input type="text" class="form-input" placeholder="Tu nombre" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Email</label>
                    <input type="email" class="form-input" placeholder="tu@email.com" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Mensaje</label>
                    <textarea class="form-input" placeholder="Escribe tu mensaje aqu√≠..."></textarea>
                </div>
                <button type="submit" class="submit-btn">Enviar Mensaje ‚ú®</button>
            </form>
        </section>
        
        <!-- Footer -->
        <footer class="footer">
            <div class="footer-links">
                <a href="https://x.com/EngelHuQ" class="footer-link" target="_blank">ùïè</a>
                <a href="https://www.linkedin.com/in/engelbert-huber-q-a95348298/" class="footer-link" target="_blank">in</a>
                <a href="https://github.com/Eiaell" class="footer-link" target="_blank">‚åò</a>
            </div>
            <p class="footer-text">
                Hecho con <span>‚ù§Ô∏è</span> y mucha magia navide√±a üéÑ<br>
                ¬© 2025 Engelbert Huber
            </p>
        </footer>
    </div>
    
    <!-- Article Modal -->
    <div class="modal-overlay" id="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <h2 class="modal-title" id="modal-title"></h2>
            <div class="modal-body" id="modal-body"></div>
        </div>
    </div>
    
    <!-- Visitor Counter -->
    <div class="visitor-counter" id="visitorCounter">
        <span class="visitor-counter-icon">üë•</span>
        <span class="visitor-counter-number" id="visitorCount">0</span>
        <span>visitas</span>
    </div>
    
    <!-- Music Toggle -->
    <button class="music-toggle" id="musicToggle" onclick="toggleMusic()">üéµ</button>
    
    <!-- Background Music (Christmas Jazz) -->
    <audio id="bgMusic" loop>
    <source src="musica.mp3" type="audio/mp3">
    </audio>
    
    <script>
        // ============================================
        // THREE.JS CHRISTMAS SCENE
        // ============================================

        let christmasTreeScene = null;
        let isTreeFocused = false;
        let currentSnowMode = 'normal';

        class ChristmasTreeScene {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.lights = [];
                this.ornaments = [];
                this.capibaras = [];
                this.presents = [];
                this.ribbons = [];
                this.snowParticles = null;
                this.snowVelocities = [];
                this.star = null;
                this.tree = null;
                this.ehuberSign = null;
                this.clock = new THREE.Clock();
                this.lightPatternIndex = 0;
                this.lightPatternTime = 0;
                this.lightPatternActive = false;
                this.lightPatternDuration = 4;
                this.lightPatterns = ['wave', 'chase', 'random', 'pulse', 'cascade'];

                this.state = {
                    isRotating: true,
                    lightsOn: true,
                    snowOn: true,
                    time: 0,
                    colorSchemeIndex: 0
                };

                this.colorSchemes = [
                    {
                        name: 'Cl√°sico',
                        treeColor: 0x228B22,
                        lights: [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff]
                    },
                    {
                        name: 'Azul Hielo',
                        treeColor: 0x1E90FF,
                        lights: [0x00bfff, 0x87ceeb, 0x4169e1, 0xffffff, 0x00ffff, 0x1e90ff, 0xe0ffff]
                    },
                    {
                        name: 'Rosa M√°gico',
                        treeColor: 0xFF69B4,
                        lights: [0xff69b4, 0xff1493, 0xda70d6, 0xffffff, 0xffb6c1, 0xff00ff, 0xffc0cb]
                    },
                    {
                        name: 'Dorado Elegante',
                        treeColor: 0xDAA520,
                        lights: [0xffd700, 0xffa500, 0xffcc00, 0xffffff, 0xffe4b5, 0xdaa520, 0xf0e68c]
                    },
                    {
                        name: 'Arco√≠ris',
                        treeColor: 'rainbow',
                        lights: [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3]
                    },
                    {
                        name: 'Rojo Pasi√≥n',
                        treeColor: 0xDC143C,
                        lights: [0xff0000, 0xdc143c, 0xb22222, 0xffffff, 0xff6347, 0xff4500, 0xffd700]
                    },
                    {
                        name: 'Blanco Invernal',
                        treeColor: 0xFFFAFA,
                        lights: [0xffffff, 0xf0f8ff, 0xe6e6fa, 0xfffafa, 0xf5f5f5, 0xadd8e6, 0xf0ffff]
                    },
                    {
                        name: 'üáµüá™ Per√∫',
                        treeColor: 'peru',
                        lights: [0xD91023, 0xFFFFFF, 0xD91023, 0xFFFFFF, 0xD91023, 0xFFD700, 0xD91023]
                    },
                    {
                        name: 'üá©üá™ Alemania',
                        treeColor: 'germany',
                        lights: [0x000000, 0xDD0000, 0xFFCC00, 0x000000, 0xDD0000, 0xFFCC00, 0xFFFFFF]
                    }
                ];

                this.config = {
                    treeHeight: 8,
                    treeLayers: 7,
                    ornamentCount: 120,
                    lightCount: 200,
                    capibaraCount: 12,
                    presentCount: 18
                };

                this.currentTreeColor = null;
                this.snowSpeedMultiplier = 1;
                this.snowModeSettings = {
                    slow: { size: 0.08, fog: 0.0005, speed: 0.4 },
                    normal: { size: 0.1, fog: 0.0008, speed: 1 },
                    storm: { size: 0.14, fog: 0.002, speed: 2.2 }
                };

                this.init();
            }

            init() {
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.setupLighting();
                this.createTree();
                this.createTreeBase();
                this.createStar();
                this.createOrnaments();
                this.createChristmasLights();
                this.createRibbons();
                this.createCapibaras();
                this.createPresents();
                this.createSnowParticles();
                this.createGround();
                this.setupControls();
                this.setupEventListeners();
                this.animate();

                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    if (loader) loader.classList.add('hidden');
                }, 1500);
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x090a0f, 0.02);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(12, 6, 12);
                this.camera.lookAt(0, 4, 0);
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambient = new THREE.AmbientLight(0x1a1a2e, 0.4);
                this.scene.add(ambient);

                const spotlight = new THREE.SpotLight(0xfff5e6, 1.5);
                spotlight.position.set(0, 20, 0);
                spotlight.angle = Math.PI / 4;
                spotlight.penumbra = 0.5;
                spotlight.decay = 1.5;
                spotlight.distance = 50;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 2048;
                spotlight.shadow.mapSize.height = 2048;
                this.scene.add(spotlight);

                const fillLight1 = new THREE.PointLight(0xff6b6b, 0.5, 20);
                fillLight1.position.set(8, 4, 8);
                this.scene.add(fillLight1);

                const fillLight2 = new THREE.PointLight(0x4ecdc4, 0.5, 20);
                fillLight2.position.set(-8, 4, -8);
                this.scene.add(fillLight2);

                const rimLight = new THREE.DirectionalLight(0xffd700, 0.3);
                rimLight.position.set(-5, 10, -5);
                this.scene.add(rimLight);
            }

            createTree() {
                this.tree = new THREE.Group();
                const layers = this.config.treeLayers;
                const totalHeight = this.config.treeHeight;

                for (let i = 0; i < layers; i++) {
                    const progress = i / (layers - 1);
                    const layerHeight = totalHeight / layers;
                    const y = i * layerHeight + 0.5;
                    const radius = 3.0 * Math.pow(1 - progress, 0.7);
                    if (radius < 0.3) continue;

                    const layerGeo = new THREE.SphereGeometry(radius, 32, 24);
                    const layerMat = new THREE.MeshStandardMaterial({
                        color: this.currentTreeColor || new THREE.Color().setHSL(0.33, 0.75, 0.18 + progress * 0.08),
                        roughness: 0.85,
                        metalness: 0,
                        emissive: 0x0d2a0d,
                        emissiveIntensity: 0.2
                    });
                    const layer = new THREE.Mesh(layerGeo, layerMat);
                    layer.scale.set(1, 0.45, 1);
                    layer.position.y = y;
                    layer.castShadow = true;
                    layer.receiveShadow = true;
                    layer.userData.isTreeLayer = true;
                    this.tree.add(layer);

                    const bumpCount = Math.floor(10 * (1 - progress * 0.5));
                    for (let b = 0; b < bumpCount; b++) {
                        const angle = (b / bumpCount) * Math.PI * 2;
                        const bumpSize = radius * 0.3;
                        const bumpGeo = new THREE.SphereGeometry(bumpSize, 12, 12);
                        const bump = new THREE.Mesh(bumpGeo, layerMat);
                        bump.position.x = Math.cos(angle) * (radius * 0.8);
                        bump.position.z = Math.sin(angle) * (radius * 0.8);
                        bump.position.y = y;
                        bump.scale.set(1, 0.5, 1);
                        bump.castShadow = true;
                        bump.userData.isTreeLayer = true;
                        this.tree.add(bump);
                    }
                }

                const topGeo = new THREE.ConeGeometry(0.4, 0.8, 16);
                const topMat = new THREE.MeshStandardMaterial({
                    color: this.currentTreeColor || new THREE.Color().setHSL(0.33, 0.75, 0.22),
                    roughness: 0.85,
                    metalness: 0,
                    emissive: 0x113611,
                    emissiveIntensity: 0.25
                });
                const top = new THREE.Mesh(topGeo, topMat);
                top.position.y = totalHeight - 0.2;
                top.castShadow = true;
                top.userData.isTreeLayer = true;
                this.tree.add(top);

                const coreGeo = new THREE.CylinderGeometry(0.5, 2, totalHeight * 0.8, 16);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0x2a5a2a, transparent: true, opacity: 0.15 });
                const core = new THREE.Mesh(coreGeo, coreMat);
                core.position.y = totalHeight / 2;
                this.tree.add(core);

                this.scene.add(this.tree);
            }

            createTreeBase() {
                const baseGroup = new THREE.Group();

                const barrelGeo = new THREE.CylinderGeometry(1.2, 1.4, 1.5, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ color: 0x5c3d2e, roughness: 0.8, metalness: 0.1 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.position.y = 0.75;
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                baseGroup.add(barrel);

                const bandMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.8 });
                for (let i = 0; i < 3; i++) {
                    const bandGeo = new THREE.TorusGeometry(1.25 - i * 0.05, 0.05, 8, 32);
                    const band = new THREE.Mesh(bandGeo, bandMat);
                    band.rotation.x = Math.PI / 2;
                    band.position.y = 0.3 + i * 0.5;
                    baseGroup.add(band);
                }

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const plankGeo = new THREE.BoxGeometry(0.05, 1.4, 0.3);
                    const plank = new THREE.Mesh(plankGeo, barrelMat);
                    plank.position.x = Math.cos(angle) * 1.25;
                    plank.position.z = Math.sin(angle) * 1.25;
                    plank.position.y = 0.75;
                    plank.rotation.y = angle;
                    baseGroup.add(plank);
                }

                this.scene.add(baseGroup);
            }

            createStar() {
                const starGroup = new THREE.Group();
                const starMat = new THREE.MeshStandardMaterial({
                    color: 0xffd700,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.5,
                    roughness: 0.2,
                    metalness: 0.9
                });

                const starShape = new THREE.Shape();
                const outerRadius = 0.6;
                const innerRadius = 0.25;
                const points = 5;

                for (let i = 0; i < points * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) {
                        starShape.moveTo(x, y);
                    } else {
                        starShape.lineTo(x, y);
                    }
                }
                starShape.closePath();

                const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.03, bevelSegments: 2 };
                const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
                starGeo.center();

                const starMesh = new THREE.Mesh(starGeo, starMat);
                starGroup.add(starMesh);

                const glowGeo = new THREE.SphereGeometry(0.7, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0xfffacd, transparent: true, opacity: 0.25 });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                starGroup.add(glow);

                const starLight = new THREE.PointLight(0xffd700, 2, 8);
                starGroup.add(starLight);

                starGroup.position.y = this.config.treeHeight + 0.4;
                this.star = starGroup;
                this.scene.add(starGroup);
            }

            createOrnaments() {
                const colors = [0xff0000, 0x0066ff, 0x00cc00, 0xffd700, 0xff69b4, 0x9932cc, 0xff6600, 0x00ffff];
                for (let i = 0; i < this.config.ornamentCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const heightPercent = Math.random() * 0.85;
                    const y = heightPercent * this.config.treeHeight + 0.8;
                    const maxRadius = 3.0 * (1 - heightPercent * 0.85);
                    const radius = maxRadius * (0.75 + Math.random() * 0.25);
                    if (heightPercent > 0.82) continue;

                    const size = 0.12 + Math.random() * 0.12;
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    const ornamentGeo = new THREE.SphereGeometry(size, 16, 16);
                    const ornamentMat = new THREE.MeshStandardMaterial({ color, roughness: 0.1, metalness: 0.9, envMapIntensity: 1.5 });
                    const ornament = new THREE.Mesh(ornamentGeo, ornamentMat);
                    ornament.position.x = Math.cos(angle) * radius;
                    ornament.position.z = Math.sin(angle) * radius;
                    ornament.position.y = y;

                    const capGeo = new THREE.CylinderGeometry(size * 0.3, size * 0.4, size * 0.3, 8);
                    const capMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 });
                    const cap = new THREE.Mesh(capGeo, capMat);
                    cap.position.y = size;
                    ornament.add(cap);

                    ornament.castShadow = true;
                    this.ornaments.push(ornament);
                    this.scene.add(ornament);
                }
            }

            createChristmasLights() {
                const lightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff];
                for (let i = 0; i < this.config.lightCount; i++) {
                    const t = (i / this.config.lightCount) * 0.85;
                    const spirals = 8;
                    const angle = t * Math.PI * 2 * spirals;
                    const y = t * this.config.treeHeight + 0.5;
                    const maxRadius = 3.1 * (1 - t * 0.82);
                    const color = lightColors[i % lightColors.length];

                    const bulbGeo = new THREE.SphereGeometry(0.08, 8, 8);
                    const bulbMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
                    const bulb = new THREE.Mesh(bulbGeo, bulbMat);
                    bulb.position.x = Math.cos(angle) * maxRadius;
                    bulb.position.z = Math.sin(angle) * maxRadius;
                    bulb.position.y = y;
                    bulb.userData = { originalColor: color, phase: Math.random() * Math.PI * 2, material: bulbMat };
                    this.lights.push(bulb);
                    this.scene.add(bulb);
                }
            }

            createRibbons() {
                const ribbonMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.4, metalness: 0.3, side: THREE.DoubleSide });
                for (let r = 0; r < 4; r++) {
                    const ribbonGroup = new THREE.Group();
                    const startY = 1 + r * 1.4;
                    if (startY > this.config.treeHeight * 0.75) continue;

                    const points = [];
                    for (let i = 0; i <= 40; i++) {
                        const t = i / 40;
                        const angle = t * Math.PI * 1.5 + r * Math.PI / 2.5;
                        const y = startY + t * 0.3;
                        const radius = 3.0 * (1 - (startY + t) / this.config.treeHeight * 0.8);
                        if (y > this.config.treeHeight * 0.8) break;
                        points.push(new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius));
                    }

                    if (points.length < 5) continue;

                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeo = new THREE.TubeGeometry(curve, 40, 0.08, 8, false);
                    const ribbon = new THREE.Mesh(tubeGeo, ribbonMat);
                    ribbon.castShadow = true;
                    ribbonGroup.add(ribbon);

                    const bowGroup = this.createBow();
                    const endPoint = points[points.length - 1];
                    bowGroup.position.copy(endPoint);
                    bowGroup.position.x *= 1.1;
                    bowGroup.position.z *= 1.1;
                    ribbonGroup.add(bowGroup);

                    this.ribbons.push(ribbonGroup);
                    this.scene.add(ribbonGroup);
                }
            }

            createBow() {
                const bowGroup = new THREE.Group();
                const bowMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.4, metalness: 0.3 });
                const loopGeo = new THREE.TorusGeometry(0.2, 0.06, 8, 16, Math.PI);

                const loop1 = new THREE.Mesh(loopGeo, bowMat);
                loop1.rotation.y = Math.PI / 4;
                loop1.position.x = 0.1;
                bowGroup.add(loop1);

                const loop2 = new THREE.Mesh(loopGeo, bowMat);
                loop2.rotation.y = -Math.PI / 4;
                loop2.position.x = -0.1;
                bowGroup.add(loop2);

                const knotGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const knot = new THREE.Mesh(knotGeo, bowMat);
                bowGroup.add(knot);

                for (let i = 0; i < 2; i++) {
                    const trailGeo = new THREE.BoxGeometry(0.08, 0.4, 0.02);
                    const trail = new THREE.Mesh(trailGeo, bowMat);
                    trail.position.y = -0.2;
                    trail.position.x = (i - 0.5) * 0.1;
                    trail.rotation.z = (i - 0.5) * 0.3;
                    bowGroup.add(trail);
                }

                bowGroup.scale.setScalar(0.8);
                return bowGroup;
            }

            createCapibaras() {
                const positions = [
                    { x: 0, y: 0.3, z: 3.8, scale: 0.9, type: 'elephant' },
                    { x: 3.8, y: 0.3, z: 0, scale: 0.8, type: 'rhino' },
                    { x: -3.5, y: 0.3, z: 1.5, scale: 0.75, type: 'elephant' },
                    { x: 2.5, y: 0.3, z: 2.5, scale: 0.7, type: 'elephant' },
                    { x: -2.5, y: 0.3, z: 2.8, scale: 0.7, type: 'rhino' },
                    { x: 0, y: 0.3, z: -3.8, scale: 0.8, type: 'elephant' },
                    { x: -3.5, y: 0.3, z: -1.5, scale: 0.7, type: 'rhino' },
                    { x: 3.2, y: 0.3, z: -2, scale: 0.65, type: 'elephant' },
                    { x: 2.2, y: 2.2, z: 2.2, scale: 0.45, type: 'elephant' },
                    { x: -1.8, y: 3.0, z: 1.8, scale: 0.4, type: 'rhino' },
                    { x: 1.5, y: 4.0, z: -1.5, scale: 0.35, type: 'elephant' },
                    { x: -1.2, y: 5.0, z: 1.2, scale: 0.32, type: 'elephant' },
                    { x: 0.9, y: 5.8, z: 0.9, scale: 0.28, type: 'rhino' },
                    { x: 2.5, y: 1.5, z: -2.5, scale: 0.42, type: 'rhino' },
                    { x: -2.2, y: 2.5, z: -1.8, scale: 0.38, type: 'elephant' },
                    { x: 1.8, y: 3.5, z: 1.2, scale: 0.36, type: 'elephant' }
                ];

                positions.forEach((pos, index) => {
                    const animal = pos.type === 'elephant' ? this.createPinkElephant() : this.createBlueRhino();
                    animal.position.set(pos.x, pos.y, pos.z);
                    animal.scale.setScalar(pos.scale);
                    animal.rotation.y = Math.atan2(pos.x, pos.z) + Math.PI + (Math.random() - 0.5) * 0.5;

                    if (index % 4 === 0) {
                        const hat = this.createSantaHat();
                        hat.position.y = pos.type === 'elephant' ? 1.4 : 1.1;
                        hat.position.x = 0.2;
                        hat.scale.setScalar(0.5);
                        animal.add(hat);
                    }

                    this.capibaras.push(animal);
                    this.scene.add(animal);
                });
            }

            createBlueRhino() {
                const rhinoGroup = new THREE.Group();
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x6495ED, roughness: 0.7, metalness: 0.1 });
                const darkerMat = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.6, metalness: 0.1 });
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFAFA, roughness: 0.4, metalness: 0.2 });
                const hornMat = new THREE.MeshStandardMaterial({ color: 0xFFE4B5, roughness: 0.5, metalness: 0.2 });

                const bodyGeo = new THREE.SphereGeometry(0.75, 24, 24);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1.2, 0.85, 0.9);
                body.position.y = 0.65;
                body.castShadow = true;
                rhinoGroup.add(body);

                const headGeo = new THREE.SphereGeometry(0.45, 24, 24);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.scale.set(1.3, 0.9, 0.9);
                head.position.set(0.75, 0.85, 0);
                head.castShadow = true;
                rhinoGroup.add(head);

                const snoutGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const snout = new THREE.Mesh(snoutGeo, bodyMat);
                snout.scale.set(1.2, 0.7, 0.85);
                snout.position.set(1.15, 0.7, 0);
                rhinoGroup.add(snout);

                const hornGeo = new THREE.ConeGeometry(0.12, 0.45, 12);
                const horn = new THREE.Mesh(hornGeo, hornMat);
                horn.position.set(1.25, 1.05, 0);
                horn.rotation.z = -0.2;
                rhinoGroup.add(horn);

                const horn2Geo = new THREE.ConeGeometry(0.08, 0.25, 10);
                const horn2 = new THREE.Mesh(horn2Geo, hornMat);
                horn2.position.set(1.0, 1.0, 0);
                horn2.rotation.z = -0.15;
                rhinoGroup.add(horn2);

                [-1, 1].forEach(side => {
                    const earGeo = new THREE.SphereGeometry(0.12, 12, 12);
                    const ear = new THREE.Mesh(earGeo, bodyMat);
                    ear.scale.set(0.5, 1, 0.7);
                    ear.position.set(0.5, 1.15, side * 0.35);
                    rhinoGroup.add(ear);

                    const innerEarGeo = new THREE.SphereGeometry(0.08, 8, 8);
                    const innerEar = new THREE.Mesh(innerEarGeo, darkerMat);
                    innerEar.scale.set(0.5, 1, 0.7);
                    innerEar.position.set(0.48, 1.15, side * 0.36);
                    rhinoGroup.add(innerEar);
                });

                const eyeGeo = new THREE.SphereGeometry(0.08, 12, 12);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x2C1810 });

                [-1, 1].forEach(side => {
                    const eyeWhiteGeo = new THREE.SphereGeometry(0.1, 12, 12);
                    const eyeWhite = new THREE.Mesh(eyeWhiteGeo, whiteMat);
                    eyeWhite.position.set(0.9, 0.95, side * 0.25);
                    rhinoGroup.add(eyeWhite);

                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    eye.position.set(0.95, 0.97, side * 0.23);
                    rhinoGroup.add(eye);

                    const shineGeo = new THREE.SphereGeometry(0.03, 8, 8);
                    const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const shine = new THREE.Mesh(shineGeo, shineMat);
                    shine.position.set(0.98, 1.0, side * 0.21);
                    rhinoGroup.add(shine);
                });

                const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.4, 12);
                const legPositions = [
                    { x: 0.4, z: 0.35 },
                    { x: 0.4, z: -0.35 },
                    { x: -0.4, z: 0.35 },
                    { x: -0.4, z: -0.35 }
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, bodyMat);
                    leg.position.set(pos.x, 0.2, pos.z);
                    leg.castShadow = true;
                    rhinoGroup.add(leg);

                    const footGeo = new THREE.SphereGeometry(0.2, 12, 12);
                    const foot = new THREE.Mesh(footGeo, bodyMat);
                    foot.scale.set(1, 0.35, 1);
                    foot.position.set(pos.x, 0.05, pos.z);
                    rhinoGroup.add(foot);
                });

                const tailGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.25, 8);
                const tail = new THREE.Mesh(tailGeo, bodyMat);
                tail.position.set(-0.85, 0.6, 0);
                tail.rotation.z = 0.5;
                rhinoGroup.add(tail);

                const cheekGeo = new THREE.SphereGeometry(0.08, 12, 12);
                const cheekMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.5 });
                [-1, 1].forEach(side => {
                    const cheek = new THREE.Mesh(cheekGeo, cheekMat);
                    cheek.scale.set(1.2, 0.8, 0.5);
                    cheek.position.set(0.85, 0.78, side * 0.32);
                    rhinoGroup.add(cheek);
                });

                return rhinoGroup;
            }

            createPinkElephant() {
                const elephantGroup = new THREE.Group();
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFFB6C1, roughness: 0.6, metalness: 0.1 });
                const darkerPinkMat = new THREE.MeshStandardMaterial({ color: 0xFF69B4, roughness: 0.5, metalness: 0.1 });
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFAFA, roughness: 0.4, metalness: 0.2 });

                const bodyGeo = new THREE.SphereGeometry(0.7, 24, 24);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1.1, 0.9, 0.85);
                body.position.y = 0.7;
                body.castShadow = true;
                elephantGroup.add(body);

                const headGeo = new THREE.SphereGeometry(0.55, 24, 24);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0.6, 1.1, 0);
                head.castShadow = true;
                elephantGroup.add(head);

                const trunkCurve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(0.95, 0.9, 0),
                    new THREE.Vector3(1.4, 0.6, 0),
                    new THREE.Vector3(1.3, 0.2, 0)
                );
                const trunkGeo = new THREE.TubeGeometry(trunkCurve, 16, 0.12, 12, false);
                const trunk = new THREE.Mesh(trunkGeo, bodyMat);
                trunk.castShadow = true;
                elephantGroup.add(trunk);

                const trunkTipGeo = new THREE.SphereGeometry(0.1, 12, 12);
                const trunkTip = new THREE.Mesh(trunkTipGeo, bodyMat);
                trunkTip.position.set(1.3, 0.2, 0);
                elephantGroup.add(trunkTip);

                [-1, 1].forEach(side => {
                    const earGeo = new THREE.SphereGeometry(0.4, 16, 16);
                    const ear = new THREE.Mesh(earGeo, bodyMat);
                    ear.scale.set(0.15, 1, 0.8);
                    ear.position.set(0.35, 1.2, side * 0.5);
                    ear.castShadow = true;
                    elephantGroup.add(ear);

                    const innerEarGeo = new THREE.SphereGeometry(0.28, 12, 12);
                    const innerEar = new THREE.Mesh(innerEarGeo, darkerPinkMat);
                    innerEar.scale.set(0.12, 1, 0.8);
                    innerEar.position.set(0.32, 1.2, side * 0.52);
                    elephantGroup.add(innerEar);
                });

                const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x2C1810 });
                const eyeWhiteGeo = new THREE.SphereGeometry(0.15, 16, 16);

                [-1, 1].forEach(side => {
                    const eyeWhite = new THREE.Mesh(eyeWhiteGeo, whiteMat);
                    eyeWhite.position.set(0.85, 1.2, side * 0.22);
                    elephantGroup.add(eyeWhite);

                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    eye.position.set(0.92, 1.22, side * 0.2);
                    elephantGroup.add(eye);

                    const shineGeo = new THREE.SphereGeometry(0.04, 8, 8);
                    const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const shine = new THREE.Mesh(shineGeo, shineMat);
                    shine.position.set(0.96, 1.26, side * 0.18);
                    elephantGroup.add(shine);
                });

                [-1, 1].forEach(side => {
                    const tuskGeo = new THREE.CylinderGeometry(0.03, 0.05, 0.25, 8);
                    const tusk = new THREE.Mesh(tuskGeo, whiteMat);
                    tusk.position.set(0.9, 0.75, side * 0.15);
                    tusk.rotation.z = side * 0.3;
                    tusk.rotation.x = 0.2;
                    elephantGroup.add(tusk);
                });

                const legGeo = new THREE.CylinderGeometry(0.18, 0.2, 0.45, 12);
                const legPositions = [
                    { x: 0.35, z: 0.3 },
                    { x: 0.35, z: -0.3 },
                    { x: -0.35, z: 0.3 },
                    { x: -0.35, z: -0.3 }
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, bodyMat);
                    leg.position.set(pos.x, 0.22, pos.z);
                    leg.castShadow = true;
                    elephantGroup.add(leg);

                    const footGeo = new THREE.SphereGeometry(0.2, 12, 12);
                    const foot = new THREE.Mesh(footGeo, bodyMat);
                    foot.scale.set(1, 0.4, 1);
                    foot.position.set(pos.x, 0.05, pos.z);
                    elephantGroup.add(foot);
                });

                const tailCurve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(-0.7, 0.7, 0),
                    new THREE.Vector3(-1, 0.5, 0),
                    new THREE.Vector3(-0.95, 0.3, 0)
                );
                const tailGeo = new THREE.TubeGeometry(tailCurve, 8, 0.05, 8, false);
                const tail = new THREE.Mesh(tailGeo, bodyMat);
                elephantGroup.add(tail);

                const tuftGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const tuft = new THREE.Mesh(tuftGeo, darkerPinkMat);
                tuft.position.set(-0.95, 0.3, 0);
                elephantGroup.add(tuft);

                const cheekGeo = new THREE.SphereGeometry(0.1, 12, 12);
                const cheekMat = new THREE.MeshBasicMaterial({ color: 0xFF91A4, transparent: true, opacity: 0.7 });
                [-1, 1].forEach(side => {
                    const cheek = new THREE.Mesh(cheekGeo, cheekMat);
                    cheek.scale.set(1.2, 0.8, 0.5);
                    cheek.position.set(0.75, 1.0, side * 0.35);
                    elephantGroup.add(cheek);
                });

                return elephantGroup;
            }

            createSantaHat() {
                const hatGroup = new THREE.Group();
                const redMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.7 });
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });

                const coneGeo = new THREE.ConeGeometry(0.5, 1, 16);
                const cone = new THREE.Mesh(coneGeo, redMat);
                cone.position.y = 0.5;
                cone.rotation.z = 0.3;
                cone.position.x = 0.1;
                hatGroup.add(cone);

                const brimGeo = new THREE.TorusGeometry(0.5, 0.12, 8, 16);
                const brim = new THREE.Mesh(brimGeo, whiteMat);
                brim.rotation.x = Math.PI / 2;
                hatGroup.add(brim);

                const pompomGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const pompom = new THREE.Mesh(pompomGeo, whiteMat);
                pompom.position.set(0.45, 0.95, 0);
                hatGroup.add(pompom);

                return hatGroup;
            }

            createPresents() {
                const allPresents = [
                    { x: -1.8, y: 0, z: 4.5, size: 0.7, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: -0.6, y: 0, z: 4.7, size: 0.75, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: 0.6, y: 0, z: 4.7, size: 0.75, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: 1.8, y: 0, z: 4.5, size: 0.7, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: -1.2, y: 0.6, z: 4.3, size: 0.55, color: 0xD91023, ribbon: 0xFFFFFF },
                    { x: 0, y: 0.65, z: 4.5, size: 0.6, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: 1.2, y: 0.6, z: 4.3, size: 0.55, color: 0xD91023, ribbon: 0xFFFFFF },
                    { x: 0, y: 1.1, z: 4.2, size: 0.45, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: 4.7, y: 0, z: 1.2, size: 0.7, color: 0xFFCC00, ribbon: 0xDD0000 },
                    { x: 4.7, y: 0.65, z: 1.2, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: 4.7, y: 1.2, z: 1.2, size: 0.5, color: 0x1A1A1A, ribbon: 0xFFCC00 },
                    { x: 4.5, y: 0, z: 0, size: 0.75, color: 0xFFCC00, ribbon: 0x1A1A1A },
                    { x: 4.5, y: 0.7, z: 0, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: 4.5, y: 1.25, z: 0, size: 0.5, color: 0x1A1A1A, ribbon: 0xDD0000 },
                    { x: 4.7, y: 0, z: -1.2, size: 0.7, color: 0xFFCC00, ribbon: 0xDD0000 },
                    { x: 4.7, y: 0.65, z: -1.2, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: 4.7, y: 1.2, z: -1.2, size: 0.5, color: 0x1A1A1A, ribbon: 0xFFCC00 },
                    { x: 1.8, y: 0, z: -4.5, size: 0.7, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: 0.6, y: 0, z: -4.7, size: 0.75, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: -0.6, y: 0, z: -4.7, size: 0.75, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: -1.8, y: 0, z: -4.5, size: 0.7, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: 1.2, y: 0.6, z: -4.3, size: 0.55, color: 0xD91023, ribbon: 0xFFFFFF },
                    { x: 0, y: 0.65, z: -4.5, size: 0.6, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: -1.2, y: 0.6, z: -4.3, size: 0.55, color: 0xD91023, ribbon: 0xFFFFFF },
                    { x: 0, y: 1.1, z: -4.2, size: 0.45, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: -4.7, y: 0, z: -1.2, size: 0.7, color: 0xFFCC00, ribbon: 0xDD0000 },
                    { x: -4.7, y: 0.65, z: -1.2, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: -4.7, y: 1.2, z: -1.2, size: 0.5, color: 0x1A1A1A, ribbon: 0xFFCC00 },
                    { x: -4.5, y: 0, z: 0, size: 0.75, color: 0xFFCC00, ribbon: 0x1A1A1A },
                    { x: -4.5, y: 0.7, z: 0, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: -4.5, y: 1.25, z: 0, size: 0.5, color: 0x1A1A1A, ribbon: 0xDD0000 },
                    { x: -4.7, y: 0, z: 1.2, size: 0.7, color: 0xFFCC00, ribbon: 0xDD0000 },
                    { x: -4.7, y: 0.65, z: 1.2, size: 0.6, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: -4.7, y: 1.2, z: 1.2, size: 0.5, color: 0x1A1A1A, ribbon: 0xFFCC00 },
                    { x: 3.2, y: 0, z: 3.2, size: 0.6, color: 0xD91023, ribbon: 0xFFFFFF },
                    { x: 3.5, y: 0, z: 3.5, size: 0.55, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: 3.0, y: 0.5, z: 3.4, size: 0.45, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: -3.2, y: 0, z: 3.2, size: 0.6, color: 0xFFCC00, ribbon: 0x1A1A1A },
                    { x: -3.5, y: 0, z: 3.5, size: 0.55, color: 0xDD0000, ribbon: 0xFFCC00 },
                    { x: -3.0, y: 0.5, z: 3.4, size: 0.45, color: 0x1A1A1A, ribbon: 0xDD0000 },
                    { x: 3.2, y: 0, z: -3.2, size: 0.6, color: 0xFFCC00, ribbon: 0xDD0000 },
                    { x: 3.5, y: 0, z: -3.5, size: 0.55, color: 0xDD0000, ribbon: 0x1A1A1A },
                    { x: 3.0, y: 0.5, z: -3.4, size: 0.45, color: 0x1A1A1A, ribbon: 0xFFCC00 },
                    { x: -3.2, y: 0, z: -3.2, size: 0.6, color: 0xD91023, ribbon: 0xFFD700 },
                    { x: -3.5, y: 0, z: -3.5, size: 0.55, color: 0xFFFFFF, ribbon: 0xD91023 },
                    { x: -3.0, y: 0.5, z: -3.4, size: 0.45, color: 0xD91023, ribbon: 0xFFFFFF }
                ];

                allPresents.forEach(config => {
                    const present = this.createFlagPresent(config, config.ribbon);
                    this.presents.push(present);
                    this.scene.add(present);
                });
            }

            createFlagPresent(config, ribbonColor) {
                const presentGroup = new THREE.Group();
                const size = config.size;
                const boxGeo = new THREE.BoxGeometry(size, size * 0.8, size);
                const boxMat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.3, metalness: 0.1 });
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.y = size * 0.4;
                box.castShadow = true;
                box.receiveShadow = true;
                presentGroup.add(box);

                const lidGeo = new THREE.BoxGeometry(size * 1.05, size * 0.12, size * 1.05);
                const lid = new THREE.Mesh(lidGeo, boxMat);
                lid.position.y = size * 0.85;
                lid.castShadow = true;
                presentGroup.add(lid);

                const ribbonMat = new THREE.MeshStandardMaterial({ color: ribbonColor, roughness: 0.3, metalness: 0.5 });
                const hRibbonGeo = new THREE.BoxGeometry(size * 1.1, size * 0.08, size * 0.12);
                const hRibbon = new THREE.Mesh(hRibbonGeo, ribbonMat);
                hRibbon.position.y = size * 0.4;
                presentGroup.add(hRibbon);

                const vRibbonGeo = new THREE.BoxGeometry(size * 0.12, size * 0.9, size * 1.1);
                const vRibbon = new THREE.Mesh(vRibbonGeo, ribbonMat);
                vRibbon.position.y = size * 0.45;
                presentGroup.add(vRibbon);

                const bow = this.createBow();
                bow.position.y = size * 0.92;
                bow.scale.setScalar(size * 0.7);
                bow.children.forEach(child => {
                    if (child.material) {
                        child.material = ribbonMat;
                    }
                });
                presentGroup.add(bow);

                presentGroup.position.set(config.x, config.y, config.z);
                presentGroup.rotation.y = Math.random() * 0.2 - 0.1;
                return presentGroup;
            }

            createSnowParticles() {
                const snowGeo = new THREE.BufferGeometry();
                const snowCount = 2000;
                const positions = new Float32Array(snowCount * 3);
                this.snowVelocities = [];

                for (let i = 0; i < snowCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 40;
                    positions[i * 3 + 1] = Math.random() * 25;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                    this.snowVelocities.push({
                        x: (Math.random() - 0.5) * 0.02,
                        y: -0.02 - Math.random() * 0.03,
                        z: (Math.random() - 0.5) * 0.02
                    });
                }

                snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
                this.snowParticles = new THREE.Points(snowGeo, snowMat);
                this.scene.add(this.snowParticles);
            }

            createGround() {
                const groundGeo = new THREE.CircleGeometry(20, 64);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 0.9, metalness: 0 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                this.scene.add(ground);

                for (let i = 0; i < 30; i++) {
                    const patchGeo = new THREE.CircleGeometry(0.3 + Math.random() * 0.5, 16);
                    const patchMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1, transparent: true, opacity: 0.3 + Math.random() * 0.3 });
                    const patch = new THREE.Mesh(patchGeo, patchMat);
                    patch.rotation.x = -Math.PI / 2;
                    patch.position.set((Math.random() - 0.5) * 15, 0.01, (Math.random() - 0.5) * 15);
                    this.scene.add(patch);
                }

                this.createEHuberSign();
            }

            createEHuberSign() {
                const signGroup = new THREE.Group();
                const bannerShape = new THREE.Shape();
                bannerShape.moveTo(-2.5, -0.5);
                bannerShape.quadraticCurveTo(-2.9, 0, -2.5, 0.5);
                bannerShape.lineTo(2.5, 0.5);
                bannerShape.quadraticCurveTo(2.9, 0, 2.5, -0.5);
                bannerShape.lineTo(-2.5, -0.5);

                const bannerGeo = new THREE.ExtrudeGeometry(bannerShape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.08, bevelSize: 0.08, bevelSegments: 4 });
                const bannerMat = new THREE.MeshStandardMaterial({ color: 0x1a0a0a, roughness: 0.3, metalness: 0.2 });
                const banner = new THREE.Mesh(bannerGeo, bannerMat);
                banner.position.z = -0.1;
                signGroup.add(banner);

                const borderMat = new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.25, metalness: 0.85, emissive: 0xDAA520, emissiveIntensity: 0.15 });

                const framePoints = [];
                for (let i = 0; i <= 60; i++) {
                    const t = i / 60;
                    const angle = t * Math.PI * 2;
                    const rx = 2.6 + Math.sin(angle * 8) * 0.08;
                    const ry = 0.55 + Math.sin(angle * 8) * 0.05;
                    framePoints.push(new THREE.Vector3(Math.cos(angle) * rx * 0.95, Math.sin(angle) * ry, 0.1));
                }
                const frameCurve = new THREE.CatmullRomCurve3(framePoints, true);
                const frameGeo = new THREE.TubeGeometry(frameCurve, 80, 0.06, 8, true);
                const frame = new THREE.Mesh(frameGeo, borderMat);
                signGroup.add(frame);

                const letterMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.15, metalness: 0.95, emissive: 0xDAA520, emissiveIntensity: 0.25 });
                const frontLetters = this.createHarryPotterLetters(letterMat);
                frontLetters.position.z = 0.22;
                signGroup.add(frontLetters);

                const backLetters = this.createHarryPotterLetters(letterMat);
                backLetters.position.z = -0.02;
                backLetters.rotation.y = Math.PI;
                signGroup.add(backLetters);

                const flourishMat = new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.2, metalness: 0.9, emissive: 0xB8860B, emissiveIntensity: 0.2 });
                [[-2.4, 0.4], [2.4, 0.4], [-2.4, -0.4], [2.4, -0.4]].forEach(([x, y]) => {
                    const flourish = this.createCornerFlourish();
                    flourish.position.set(x, y, 0.15);
                    flourish.scale.setScalar(0.15);
                    if (x > 0) flourish.scale.x *= -1;
                    if (y < 0) flourish.scale.y *= -1;
                    signGroup.add(flourish);
                });

                const chainMat = new THREE.MeshStandardMaterial({ color: 0xB8860B, roughness: 0.3, metalness: 0.8 });
                [-1.8, 1.8].forEach(x => {
                    const chainCurve = new THREE.QuadraticBezierCurve3(
                        new THREE.Vector3(x, 0.5, 0.1),
                        new THREE.Vector3(x * 0.8, 1.2, 0),
                        new THREE.Vector3(0, 1.5, 0)
                    );
                    const chainGeo = new THREE.TubeGeometry(chainCurve, 20, 0.03, 8, false);
                    const chain = new THREE.Mesh(chainGeo, chainMat);
                    signGroup.add(chain);
                });

                signGroup.position.set(0, this.config.treeHeight + 3, 0);
                this.ehuberSign = signGroup;
                this.scene.add(signGroup);

                const signLight = new THREE.PointLight(0xFFD700, 1.5, 6);
                signLight.position.set(0, this.config.treeHeight + 3, 2);
                this.scene.add(signLight);
                const signLightBack = new THREE.PointLight(0xFFD700, 1.5, 6);
                signLightBack.position.set(0, this.config.treeHeight + 3, -2);
                this.scene.add(signLightBack);
            }

            createCornerFlourish() {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.2, metalness: 0.9 });
                const spiralPoints = [];
                for (let i = 0; i <= 20; i++) {
                    const t = i / 20;
                    const angle = t * Math.PI * 1.5;
                    const radius = 0.5 + t * 1.5;
                    spiralPoints.push(new THREE.Vector3(Math.cos(angle) * radius * 0.3, Math.sin(angle) * radius * 0.3, 0));
                }
                const spiralCurve = new THREE.CatmullRomCurve3(spiralPoints);
                const spiralGeo = new THREE.TubeGeometry(spiralCurve, 20, 0.15, 8, false);
                const spiral = new THREE.Mesh(spiralGeo, mat);
                group.add(spiral);
                return group;
            }

            createHarryPotterLetters(material) {
                const group = new THREE.Group();
                const h = 0.55;
                const w = 0.1;
                const d = 0.12;
                const letters = [];

                const eGroup = new THREE.Group();
                const eVert = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                eVert.position.x = -0.12;
                eGroup.add(eVert);
                [-0.22, 0, 0.22].forEach((y, i) => {
                    const width = i === 1 ? 0.22 : 0.28;
                    const eHorz = new THREE.Mesh(new THREE.BoxGeometry(width, w * 0.9, d), material);
                    eHorz.position.set(0.02 + (i === 1 ? -0.03 : 0), y, 0);
                    eGroup.add(eHorz);
                    if (i !== 1) {
                        const serif = new THREE.Mesh(new THREE.ConeGeometry(w * 0.5, w, 4), material);
                        serif.rotation.z = -Math.PI / 2;
                        serif.position.set(0.18, y, 0);
                        eGroup.add(serif);
                    }
                });
                letters.push(eGroup);

                const dotGroup = new THREE.Group();
                const dot = new THREE.Mesh(new THREE.OctahedronGeometry(0.08, 0), material);
                dot.rotation.z = Math.PI / 4;
                dot.position.y = -0.2;
                dot.scale.z = 0.5;
                dotGroup.add(dot);
                letters.push(dotGroup);

                const hGroup = new THREE.Group();
                [-0.12, 0.12].forEach(x => {
                    const hVert = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                    hVert.position.x = x;
                    hGroup.add(hVert);
                    const topSerif = new THREE.Mesh(new THREE.ConeGeometry(w * 0.6, w * 1.2, 4), material);
                    topSerif.position.set(x, h / 2 + w * 0.5, 0);
                    hGroup.add(topSerif);
                });
                const hMid = new THREE.Mesh(new THREE.BoxGeometry(0.24, w * 0.9, d), material);
                hGroup.add(hMid);
                letters.push(hGroup);

                const uGroup = new THREE.Group();
                [-0.1, 0.1].forEach(x => {
                    const uVert = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.55, d), material);
                    uVert.position.set(x, 0.08, 0);
                    uGroup.add(uVert);
                });
                const uBot = new THREE.Mesh(new THREE.TorusGeometry(0.1, w * 0.5, 8, 12, Math.PI), material);
                uBot.rotation.z = Math.PI;
                uBot.rotation.x = Math.PI / 2;
                uBot.position.y = -0.12;
                uGroup.add(uBot);
                letters.push(uGroup);

                const bGroup = new THREE.Group();
                const bVert = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                bVert.position.x = -0.1;
                bGroup.add(bVert);
                const bSerif = new THREE.Mesh(new THREE.ConeGeometry(w * 0.6, w * 1.2, 4), material);
                bSerif.position.set(-0.1, h / 2 + w * 0.5, 0);
                bGroup.add(bSerif);
                const bBowl = new THREE.Mesh(new THREE.TorusGeometry(0.13, w * 0.5, 8, 12, Math.PI), material);
                bBowl.rotation.z = -Math.PI / 2;
                bBowl.position.set(0.03, -0.07, 0);
                bGroup.add(bBowl);
                letters.push(bGroup);

                const e2Group = new THREE.Group();
                const eBowl = new THREE.Mesh(new THREE.TorusGeometry(0.12, w * 0.5, 8, 16, Math.PI * 1.4), material);
                eBowl.rotation.z = Math.PI * 0.3;
                eBowl.position.y = -0.05;
                e2Group.add(eBowl);
                const eMid = new THREE.Mesh(new THREE.BoxGeometry(0.2, w * 0.8, d), material);
                eMid.position.set(0.02, -0.03, 0);
                e2Group.add(eMid);
                letters.push(e2Group);

                const rGroup = new THREE.Group();
                const rVert = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.5, d), material);
                rVert.position.set(-0.06, -0.08, 0);
                rGroup.add(rVert);
                const rCurve = new THREE.Mesh(new THREE.TorusGeometry(0.1, w * 0.5, 8, 8, Math.PI * 0.6), material);
                rCurve.rotation.z = Math.PI * 0.7;
                rCurve.position.set(0.04, 0.1, 0);
                rGroup.add(rCurve);
                letters.push(rGroup);

                let xOffset = -1.6;
                letters.forEach((letter, i) => {
                    letter.position.x = xOffset;
                    group.add(letter);
                    xOffset += 0.5;
                    if (i === 1) xOffset += 0.1;
                });

                return group;
            }

            setupControls() {
                this.isDragging = false;
                this.previousMousePosition = { x: 0, y: 0 };
                this.spherical = { radius: 17, theta: Math.PI / 4, phi: Math.PI / 3 };
                const canvas = this.renderer.domElement;

                canvas.addEventListener('mousedown', e => {
                    this.isDragging = true;
                    this.previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mousemove', e => {
                    if (!this.isDragging) return;
                    const deltaX = e.clientX - this.previousMousePosition.x;
                    const deltaY = e.clientY - this.previousMousePosition.y;
                    this.spherical.theta -= deltaX * 0.005;
                    this.spherical.phi = Math.max(0.3, Math.min(Math.PI / 2, this.spherical.phi - deltaY * 0.005));
                    this.previousMousePosition = { x: e.clientX, y: e.clientY };
                    this.updateCameraPosition();
                });

                canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                });

                canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.spherical.radius = Math.max(8, Math.min(30, this.spherical.radius + e.deltaY * 0.01));
                    this.updateCameraPosition();
                }, { passive: false });

                canvas.addEventListener('touchstart', e => {
                    if (e.touches.length === 1) {
                        this.isDragging = true;
                        this.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                });

                canvas.addEventListener('touchmove', e => {
                    if (!this.isDragging || e.touches.length !== 1) return;
                    const deltaX = e.touches[0].clientX - this.previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - this.previousMousePosition.y;
                    this.spherical.theta -= deltaX * 0.005;
                    this.spherical.phi = Math.max(0.3, Math.min(Math.PI / 2, this.spherical.phi - deltaY * 0.005));
                    this.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    this.updateCameraPosition();
                });

                canvas.addEventListener('touchend', () => {
                    this.isDragging = false;
                });
            }

            updateCameraPosition() {
                const { radius, theta, phi } = this.spherical;
                this.camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                this.camera.position.y = radius * Math.cos(phi) + 4;
                this.camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
                this.camera.lookAt(0, 4, 0);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                const toggleSnowBtn = document.getElementById('toggleSnow');
                if (toggleSnowBtn) {
                    toggleSnowBtn.addEventListener('click', () => this.toggleSnow());
                }

                const toggleLightsBtn = document.getElementById('toggleLights');
                if (toggleLightsBtn) {
                    toggleLightsBtn.addEventListener('click', () => this.toggleLights());
                }

                const toggleRotationBtn = document.getElementById('toggleRotation');
                if (toggleRotationBtn) {
                    toggleRotationBtn.addEventListener('click', () => this.toggleRotation());
                }

                const changeColorBtn = document.getElementById('changeColor');
                if (changeColorBtn) {
                    changeColorBtn.addEventListener('click', () => this.changeColorScheme());
                }

                const resetCameraBtn = document.getElementById('resetCamera');
                if (resetCameraBtn) {
                    resetCameraBtn.addEventListener('click', () => this.resetCamera());
                }
            }

            toggleSnow() {
                this.state.snowOn = !this.state.snowOn;
                if (this.snowParticles) {
                    this.snowParticles.visible = this.state.snowOn;
                }
                const btn = document.getElementById('toggleSnow');
                if (btn) {
                    btn.textContent = this.state.snowOn ? '‚ùÑÔ∏è Nieve' : 'üö´ Nieve';
                }
            }

            toggleLights() {
                this.state.lightsOn = !this.state.lightsOn;
                const btn = document.getElementById('toggleLights');
                if (btn) {
                    btn.textContent = this.state.lightsOn ? 'üí° Luces' : 'üí° Luces OFF';
                }
            }

            toggleRotation() {
                this.state.isRotating = !this.state.isRotating;
                const btn = document.getElementById('toggleRotation');
                if (btn) {
                    btn.textContent = this.state.isRotating ? 'üîÑ Rotaci√≥n' : '‚è∏Ô∏è Rotaci√≥n';
                }
            }

            resetCamera() {
                this.spherical = { radius: 17, theta: Math.PI / 4, phi: Math.PI / 3 };
                this.updateCameraPosition();
            }

            triggerSpin() {
                this.state.isRotating = true;
                this.spherical.theta += Math.PI;
            }

            sparkleLights() {
                if (!this.lights.length) return;
                
                this.lightPatternIndex = (this.lightPatternIndex + 1) % this.lightPatterns.length;
                this.lightPatternTime = 0;
                this.lightPatternActive = true;
                
                const patternNames = {
                    'wave': 'üåä Ola',
                    'chase': 'üèÉ Persecuci√≥n',
                    'random': 'üé≤ Aleatorio',
                    'pulse': 'üíì Pulso',
                    'cascade': 'üåà Cascada'
                };
                
                this.showColorNotification(patternNames[this.lightPatterns[this.lightPatternIndex]]);
                
                if (this.star) {
                    this.star.scale.setScalar(1.4);
                    setTimeout(() => this.star.scale.setScalar(1), 500);
                }
            }
            
            updateLightPattern(delta) {
                if (!this.lightPatternActive || !this.lights.length) return;
                
                this.lightPatternTime += delta;
                const pattern = this.lightPatterns[this.lightPatternIndex];
                const t = this.lightPatternTime;
                
                switch (pattern) {
                    case 'wave':
                        this.lights.forEach((light, i) => {
                            const wavePos = (t * 2) % 1;
                            const lightPos = light.position.y / this.config.treeHeight;
                            const dist = Math.abs(lightPos - wavePos);
                            const intensity = Math.max(0, 1 - dist * 4);
                            light.userData.material.opacity = 0.3 + intensity * 0.7;
                            light.scale.setScalar(0.8 + intensity * 1.2);
                        });
                        break;
                        
                    case 'chase':
                        this.lights.forEach((light, i) => {
                            const chasePos = Math.floor(t * 30) % this.lights.length;
                            const distance = Math.abs(i - chasePos);
                            const trail = Math.max(0, 1 - distance / 15);
                            light.userData.material.opacity = 0.2 + trail * 0.8;
                            light.scale.setScalar(0.6 + trail * 1.4);
                        });
                        break;
                        
                    case 'random':
                        if (Math.floor(t * 10) !== Math.floor((t - delta) * 10)) {
                            this.lights.forEach(light => {
                                const on = Math.random() > 0.4;
                                light.userData.material.opacity = on ? 1 : 0.15;
                                light.scale.setScalar(on ? 1.5 : 0.5);
                            });
                        }
                        break;
                        
                    case 'pulse':
                        const pulseIntensity = (Math.sin(t * 8) + 1) / 2;
                        this.lights.forEach(light => {
                            light.userData.material.opacity = 0.2 + pulseIntensity * 0.8;
                            light.scale.setScalar(0.6 + pulseIntensity * 1.2);
                        });
                        break;
                        
                    case 'cascade':
                        const colors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x9400d3];
                        this.lights.forEach((light, i) => {
                            const colorIdx = Math.floor((t * 3 + i * 0.05) % colors.length);
                            light.userData.material.color.setHex(colors[colorIdx]);
                            light.userData.material.opacity = 0.9;
                            light.scale.setScalar(1.2);
                        });
                        break;
                }
                
                if (this.lightPatternTime >= this.lightPatternDuration) {
                    this.lightPatternActive = false;
                    this.lights.forEach(light => {
                        light.userData.material.color.setHex(light.userData.originalColor);
                    });
                }
            }

            addDynamicOrnament() {
                const colors = [0xff0000, 0x0066ff, 0x00cc00, 0xffd700, 0xff69b4, 0x9932cc];
                const angle = Math.random() * Math.PI * 2;
                const heightPercent = Math.random() * 0.8;
                const y = heightPercent * this.config.treeHeight + 0.8;
                const maxRadius = 3.0 * (1 - heightPercent * 0.85);
                const radius = maxRadius * (0.75 + Math.random() * 0.25);
                const size = 0.15 + Math.random() * 0.1;
                const color = colors[Math.floor(Math.random() * colors.length)];

                const ornamentGeo = new THREE.SphereGeometry(size, 16, 16);
                const ornamentMat = new THREE.MeshStandardMaterial({ color, roughness: 0.1, metalness: 0.9, envMapIntensity: 1.5 });
                const ornament = new THREE.Mesh(ornamentGeo, ornamentMat);
                ornament.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                ornament.castShadow = true;
                this.ornaments.push(ornament);
                this.scene.add(ornament);
            }

            setSnowMode(mode) {
                this.currentSnowMode = mode;
                const settings = this.snowModeSettings[mode] || this.snowModeSettings.normal;
                if (this.snowParticles) {
                    this.snowParticles.material.size = settings.size;
                }
                if (this.scene && this.scene.fog) {
                    this.scene.fog.density = settings.fog;
                }
                this.snowSpeedMultiplier = settings.speed;
            }

            changeColorScheme() {
                this.state.colorSchemeIndex = (this.state.colorSchemeIndex + 1) % this.colorSchemes.length;
                const scheme = this.colorSchemes[this.state.colorSchemeIndex];
                let layerIndex = 0;
                const totalLayers = this.tree.children.filter(c => c.userData.isTreeLayer).length;

                this.tree.traverse(child => {
                    if (child.isMesh && child.userData.isTreeLayer) {
                        let newColor;
                        if (scheme.treeColor === 'rainbow') {
                            const rainbowColors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3];
                            const colorIndex = Math.floor((layerIndex / totalLayers) * rainbowColors.length);
                            newColor = new THREE.Color(rainbowColors[Math.min(colorIndex, rainbowColors.length - 1)]);
                        } else if (scheme.treeColor === 'peru') {
                            const section = Math.floor((layerIndex / totalLayers) * 3);
                            newColor = new THREE.Color(section === 0 || section === 2 ? 0xD91023 : 0xFFFFFF);
                        } else if (scheme.treeColor === 'germany') {
                            const section = Math.floor((layerIndex / totalLayers) * 3);
                            if (section === 0) newColor = new THREE.Color(0xFFCC00);
                            else if (section === 1) newColor = new THREE.Color(0xDD0000);
                            else newColor = new THREE.Color(0x1a1a1a);
                        } else {
                            newColor = new THREE.Color(scheme.treeColor);
                        }
                        child.material.color.copy(newColor);
                        child.material.needsUpdate = true;
                        layerIndex++;
                    }
                });

                this.lights.forEach((light, i) => {
                    const newColor = scheme.lights[i % scheme.lights.length];
                    light.userData.originalColor = newColor;
                    light.userData.material.color.setHex(newColor);
                });

                this.showColorNotification(scheme.name);
            }

            showColorNotification(name) {
                const existing = document.getElementById('colorNotification');
                if (existing) existing.remove();
                const notification = document.createElement('div');
                notification.id = 'colorNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #ffd700;
                    padding: 20px 40px;
                    border-radius: 15px;
                    font-family: 'Cinzel Decorative', cursive;
                    font-size: 1.5rem;
                    z-index: 1000;
                    border: 2px solid #ffd700;
                    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
                    animation: fadeInOut 1.5s ease-in-out forwards;
                `;
                notification.textContent = `üé® ${name}`;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 1500);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock ? this.clock.getDelta() : 0.016;
                this.state.time += delta;

                if (this.state.isRotating && !this.isDragging) {
                    this.spherical.theta += 0.002;
                    this.updateCameraPosition();
                }

                if (!this.lightPatternActive) {
                    if (this.state.lightsOn) {
                        this.lights.forEach(light => {
                            const intensity = 0.5 + 0.5 * Math.sin(this.state.time * 3 + light.userData.phase);
                            light.userData.material.opacity = intensity;
                            light.scale.setScalar(0.8 + intensity * 0.4);
                        });
                    } else {
                        this.lights.forEach(light => {
                            light.userData.material.opacity = 0.1;
                            light.scale.setScalar(0.5);
                        });
                    }
                }

                if (this.state.snowOn && this.snowParticles) {
                    const positions = this.snowParticles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length / 3; i++) {
                        positions[i * 3] += this.snowVelocities[i].x * this.snowSpeedMultiplier;
                        positions[i * 3 + 1] += this.snowVelocities[i].y * this.snowSpeedMultiplier;
                        positions[i * 3 + 2] += this.snowVelocities[i].z * this.snowSpeedMultiplier;
                        positions[i * 3] += Math.sin(this.state.time + i) * 0.002 * this.snowSpeedMultiplier;
                        if (positions[i * 3 + 1] < 0) {
                            positions[i * 3] = (Math.random() - 0.5) * 40;
                            positions[i * 3 + 1] = 25;
                            positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                        }
                    }
                    this.snowParticles.geometry.attributes.position.needsUpdate = true;
                }

                this.capibaras.forEach((capibara, i) => {
                    const breathe = 1 + Math.sin(this.state.time * 1.5 + i) * 0.02;
                    capibara.scale.y = capibara.scale.x * breathe;
                });

                if (this.ehuberSign) {
                    this.ehuberSign.position.y = this.config.treeHeight + 3 + Math.sin(this.state.time * 0.8) * 0.08;
                    this.ehuberSign.rotation.y += 0.003;
                }

                this.ornaments.forEach((ornament, i) => {
                    ornament.rotation.z = Math.sin(this.state.time * 0.5 + i * 0.1) * 0.05;
                });

                if (this.star) {
                    this.star.rotation.y += 0.01;
                    const baseScale = 1 + Math.sin(this.state.time * 2) * 0.05;
                    this.star.scale.setScalar(baseScale);
                }

                this.updateLightPattern(delta);

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('load', () => {
            christmasTreeScene = new ChristmasTreeScene();
            christmasTreeScene.setSnowMode(currentSnowMode);
            const sparkleButton = document.getElementById('sparkleBtn');
            if (sparkleButton) {
                sparkleButton.addEventListener('click', () => christmasTreeScene?.sparkleLights());
            }
        });

        function createSnowflake() {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.textContent = '‚ùÑ';
            snowflake.style.left = Math.random() * 100 + 'vw';
            snowflake.style.animationDuration = (5 + Math.random() * 10) + 's';
            snowflake.style.opacity = Math.random() * 0.5 + 0.3;
            snowflake.style.fontSize = (8 + Math.random() * 12) + 'px';
            document.body.appendChild(snowflake);
            setTimeout(() => snowflake.remove(), 15000);
        }

        setInterval(createSnowflake, 500);
        
        // ============================================
        // MODAL FUNCTIONS
        // ============================================
        
        const articleContent = {
            rag: {
                title: 'RAG: La Revoluci√≥n de la IA Generativa',
                body: `
                    <p>La Generaci√≥n Aumentada por Recuperaci√≥n (RAG) representa uno de los avances m√°s significativos en el campo de la inteligencia artificial generativa. Esta tecnolog√≠a permite a los modelos de lenguaje acceder a informaci√≥n actualizada y espec√≠fica, superando una de sus principales limitaciones.</p>
                    
                    <h2>¬øC√≥mo Funciona RAG?</h2>
                    <p>El proceso de RAG se divide en tres fases fundamentales: Recuperaci√≥n, donde el sistema busca informaci√≥n relevante en bases de datos; Procesamiento, donde se combina esta informaci√≥n con el contexto de la consulta; y Generaci√≥n, donde el modelo produce una respuesta informada y precisa.</p>
                    
                    <h2>Aplicaciones Pr√°cticas</h2>
                    <p>Desde chatbots empresariales hasta sistemas de soporte t√©cnico, RAG est√° transformando c√≥mo las organizaciones implementan soluciones de IA. La capacidad de mantener respuestas actualizadas sin necesidad de reentrenar modelos completos representa un cambio de paradigma.</p>
                    
                    <p>El futuro de RAG promete integraciones m√°s sofisticadas, con capacidades multimodales y comprensi√≥n contextual mejorada. Estamos apenas al inicio de esta revoluci√≥n.</p>
                `
            },
            ai: {
                title: 'El Futuro de la Inteligencia Artificial',
                body: `
                    <p>La inteligencia artificial est√° evolucionando a un ritmo sin precedentes. Cada d√≠a surgen nuevas capacidades que hace apenas unos a√±os parec√≠an ciencia ficci√≥n. Pero, ¬øhacia d√≥nde nos dirigimos?</p>
                    
                    <h2>Tendencias Emergentes</h2>
                    <p>Los modelos multimodales, capaces de procesar texto, imagen, audio y video simult√°neamente, est√°n definiendo el nuevo est√°ndar. La integraci√≥n de IA en dispositivos edge y la democratizaci√≥n del acceso a estas tecnolog√≠as est√°n creando oportunidades sin precedentes.</p>
                    
                    <h2>Desaf√≠os √âticos</h2>
                    <p>Con gran poder viene gran responsabilidad. La comunidad tecnol√≥gica est√° cada vez m√°s consciente de la necesidad de desarrollar IA de manera √©tica y responsable, considerando impactos sociales, sesgos algor√≠tmicos y privacidad de datos.</p>
                    
                    <p>El futuro de la IA no est√° escrito. Depende de las decisiones que tomemos hoy como sociedad.</p>
                `
            },
            christmas: {
                title: 'IA y la Magia de la Navidad',
                body: `
                    <p>¬øQu√© pasar√≠a si la tecnolog√≠a m√°s avanzada se encontrara con la tradici√≥n m√°s antigua? La Navidad de 2025 est√° siendo transformada por la inteligencia artificial de maneras sorprendentes y maravillosas.</p>
                    
                    <h2>Experiencias Personalizadas</h2>
                    <p>Los asistentes de IA ahora pueden crear listas de regalos perfectamente personalizadas, considerando no solo preferencias expl√≠citas sino tambi√©n patrones de comportamiento y relaciones interpersonales. Santa Claus tiene un nuevo ayudante digital.</p>
                    
                    <h2>Decoraciones Inteligentes</h2>
                    <p>Desde luces que se sincronizan con m√∫sica navide√±a en tiempo real hasta √°rboles de Navidad con realidad aumentada, la tecnolog√≠a est√° a√±adiendo nuevas capas de magia a nuestras celebraciones tradicionales.</p>
                    
                    <p>Este blog que est√°s viendo es un ejemplo: Three.js y IA trabajando juntos para crear una experiencia navide√±a inolvidable. ¬°Feliz Navidad! üéÑ</p>
                `
            },
            peru: {
                title: 'Tecnolog√≠a en Per√∫: Un An√°lisis',
                body: `
                    <p>El ecosistema tecnol√≥gico peruano est√° experimentando una transformaci√≥n acelerada. Startups, corporaciones y el gobierno est√°n convergiendo hacia una visi√≥n digital del futuro del pa√≠s.</p>
                    
                    <h2>Oportunidades de Crecimiento</h2>
                    <p>Con una poblaci√≥n joven y cada vez m√°s conectada, Per√∫ presenta oportunidades √∫nicas para la innovaci√≥n tecnol√≥gica. El sector fintech lidera el camino, seguido de cerca por healthtech y edtech.</p>
                    
                    <h2>Desaf√≠os por Superar</h2>
                    <p>La brecha digital sigue siendo un obst√°culo significativo. El acceso desigual a internet y la falta de educaci√≥n tecnol√≥gica en zonas rurales requieren atenci√≥n urgente para un desarrollo tecnol√≥gico verdaderamente inclusivo.</p>
                    
                    <p>El potencial est√° ah√≠. Solo necesitamos la voluntad colectiva para realizarlo.</p>
                `
            },
            vibecoding: {
                title: 'Vibecoding: El Nuevo Paradigma',
                body: `
                    <p>Imagina programar sin escribir una sola l√≠nea de c√≥digo, solo describiendo lo que quieres crear. Eso es vibecoding, y est√° cambiando fundamentalmente nuestra relaci√≥n con el desarrollo de software.</p>
                    
                    <h2>M√°s All√° del C√≥digo Tradicional</h2>
                    <p>El vibecoding no reemplaza el conocimiento t√©cnico; lo amplifica. Permite a desarrolladores experimentados ser m√°s productivos y abre las puertas de la creaci√≥n tecnol√≥gica a nuevas audiencias.</p>
                    
                    <h2>El Rol del Desarrollador Evoluciona</h2>
                    <p>Los programadores del futuro ser√°n m√°s arquitectos y directores creativos que escritores de sintaxis. La habilidad de comunicar intenci√≥n clara y estructurar problemas complejos ser√° m√°s valiosa que memorizar APIs.</p>
                    
                    <p>El c√≥digo no desaparece; simplemente cambia qui√©n y c√≥mo lo escribe. Bienvenido al futuro del desarrollo.</p>
                `
            },
            ml: {
                title: 'Machine Learning desde Cero',
                body: `
                    <p>¬øEs posible entrenar un modelo de lenguaje con recursos limitados? Mi experiencia con GPT-2 demostr√≥ que s√≠. Con una GTX 1660 Ti y 67 minutos, logr√© crear algo que antes requer√≠a infraestructura millonaria.</p>
                    
                    <h2>El Viaje de Aprendizaje</h2>
                    <p>Comenzar desde cero significa entender cada componente: tokenizaci√≥n, arquitectura transformer, funciones de p√©rdida, optimizaci√≥n. No hay atajos, pero cada paso construye comprensi√≥n profunda.</p>
                    
                    <h2>Lecciones Aprendidas</h2>
                    <p>Los datos lo son todo. Un modelo peque√±o con datos de calidad puede superar a modelos m√°s grandes con datos ruidosos. La curaci√≥n y limpieza de datasets es tan importante como la arquitectura del modelo.</p>
                    
                    <p>Machine learning ya no es solo para gigantes tecnol√≥gicos. Con determinaci√≥n y recursos modestos, cualquiera puede entrar a este fascinante campo.</p>
                `
            }
        };
        
        function openModal(articleId) {
            const modal = document.getElementById('modal');
            const title = document.getElementById('modal-title');
            const body = document.getElementById('modal-body');
            
            const article = articleContent[articleId];
            if (article) {
                title.innerHTML = article.title;
                body.innerHTML = article.body;
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }
        
        function closeModal() {
            const modal = document.getElementById('modal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        // Close modal on outside click
        document.getElementById('modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
        
        // ============================================
        // NAVIGATION SCROLL EFFECT
        // ============================================
        
        window.addEventListener('scroll', function() {
            const nav = document.getElementById('nav');
            if (window.scrollY > 100) {
                nav.classList.add('scrolled');
            } else {
                nav.classList.remove('scrolled');
            }
        });
        
        // ============================================
        // MUSIC TOGGLE
        // ============================================
        
        // Configurar inicio en el segundo 25
        document.addEventListener('DOMContentLoaded', function() {
            var audio = document.getElementById("bgMusic");
            if(audio) {
                audio.currentTime = 25;
            }
        });

        let isPlaying = false;
        
        function toggleMusic() {
            const audio = document.getElementById('bgMusic');
            const btn = document.getElementById('musicToggle');
            
            if (isPlaying) {
                audio.pause();
                btn.classList.remove('playing');
                btn.textContent = 'üéµ';
            } else {
                audio.play().catch(() => {
                    console.log('Audio autoplay blocked');
                });
                btn.classList.add('playing');
                btn.textContent = 'üîä';
            }
            isPlaying = !isPlaying;
        }
        
        // ============================================
        // FORM HANDLING WITH EMAILJS
        // ============================================
        
        // Initialize EmailJS
        (function() {
            emailjs.init("NorjYgoE2kOq27n0O");
        })();
        
        function handleSubmit(event) {
            event.preventDefault();
            
            const form = event.target;
            const submitBtn = form.querySelector('.submit-btn');
            const originalText = submitBtn.innerHTML;
            
            // Get form values
            const name = form.querySelector('input[type="text"]').value;
            const email = form.querySelector('input[type="email"]').value;
            const message = form.querySelector('textarea').value;
            
            // Show loading state
            submitBtn.innerHTML = 'Enviando... ‚è≥';
            submitBtn.disabled = true;
            
            // Send email using EmailJS - usando tu configuraci√≥n existente
            emailjs.send("service_bq58uoc", "template_udfawus", {
                user_email: email,
                to_name: "Engelbert Huber",
                from_name: name,
                message: "Mensaje de contacto desde el blog navide√±o:\n\nNombre: " + name + "\nEmail: " + email + "\n\nMensaje:\n" + message,
                reply_to: email
            }).then(function(response) {
                console.log('Email sent successfully:', response);
                submitBtn.innerHTML = '¬°Enviado! ‚úÖ';
                alert('¬°Mensaje enviado! üéÑ Gracias por contactarme. Te responder√© pronto.');
                form.reset();
                setTimeout(() => {
                    submitBtn.innerHTML = originalText;
                    submitBtn.disabled = false;
                }, 2000);
            }).catch(function(error) {
                console.error('Email error:', error);
                submitBtn.innerHTML = 'Error ‚ùå';
                alert('Hubo un error al enviar el mensaje. Por favor intenta de nuevo.');
                setTimeout(() => {
                    submitBtn.innerHTML = originalText;
                    submitBtn.disabled = false;
                }, 2000);
            });
        }
        
        // ============================================
        // TOGGLE ARTICLES (MOBILE)
        // ============================================
        
        let articlesExpanded = false;
        
        function toggleArticles() {
            const hiddenArticles = document.querySelectorAll('.mobile-hidden-article');
            const btn = document.getElementById('showMoreBtn');
            
            articlesExpanded = !articlesExpanded;
            
            hiddenArticles.forEach(article => {
                if (articlesExpanded) {
                    article.classList.add('show');
                } else {
                    article.classList.remove('show');
                }
            });
            
            btn.textContent = articlesExpanded ? 'Ver menos art√≠culos ‚ñ≤' : 'Ver m√°s art√≠culos ‚ú®';
        }
        
        // ============================================
        // SMOOTH SCROLL FOR NAV LINKS
        // ============================================
        
        document.querySelectorAll('.nav-links a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });
        
        // ============================================
        // TREE INTERACTIVE MODE
        // ============================================
        
        function toggleTreeFocus() {
            if (!isTreeFocused) {
                enterTreeFocus();
            } else {
                exitTreeFocus();
            }
        }
        
        function enterTreeFocus() {
            if (isTreeFocused) return;
            isTreeFocused = true;
            document.body.classList.add('tree-focus-active');
            document.getElementById('treeToggle').classList.add('active');
            document.getElementById('treeControls').classList.add('visible');
            document.body.style.cursor = 'grab';
            christmasTreeScene?.resetCamera();
            
            // Scroll to top for best view
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        function exitTreeFocus() {
            isTreeFocused = false;
            document.body.classList.remove('tree-focus-active');
            document.getElementById('treeToggle').classList.remove('active');
            document.getElementById('treeControls').classList.remove('visible');
            document.body.style.cursor = '';
            
            // Reset cursor
            document.body.style.cursor = 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="24" font-size="24">‚ùÑÔ∏è</text></svg>\'), auto';
        }
        
        function spinTree() {
            christmasTreeScene?.triggerSpin();
        }
        function changeTreeColors() {
            christmasTreeScene?.changeColorScheme();
        }
        function addOrnament() {
            christmasTreeScene?.addDynamicOrnament();
        }
        
        // ============================================
        // SNOW MODES
        // ============================================
        
        function toggleSnowModes() {
            const modesPanel = document.getElementById('snowModes');
            const snowToggle = document.getElementById('snowToggle');
            
            modesPanel.classList.toggle('visible');
            snowToggle.classList.toggle('active');
        }
        
        function setSnowMode(evt, mode) {
            currentSnowMode = mode;
            document.querySelectorAll('.snow-mode-btn').forEach(btn => btn.classList.remove('active'));
            if (evt && evt.target) {
                evt.target.classList.add('active');
            }
            christmasTreeScene?.setSnowMode(mode);
            const snowToggle = document.getElementById('snowToggle');
            snowToggle.style.transform = 'translateX(10px)';
            setTimeout(() => {
                snowToggle.style.transform = '';
            }, 200);
        }
        
        // ============================================
        // VISITOR COUNTER
        // ============================================
        
        (function initVisitorCounter() {
            const STORAGE_KEY = 'navidad_visitor_count';
            const SESSION_KEY = 'navidad_session_counted';
            
            let count = parseInt(localStorage.getItem(STORAGE_KEY) || '0', 10);
            
            // Solo incrementar si es una nueva sesion
            if (!sessionStorage.getItem(SESSION_KEY)) {
                count++;
                localStorage.setItem(STORAGE_KEY, count.toString());
                sessionStorage.setItem(SESSION_KEY, 'true');
            }
            
            // Mostrar el contador
            const counterElement = document.getElementById('visitorCount');
            if (counterElement) {
                counterElement.textContent = count.toLocaleString('es-ES');
            }
        })();

    </script>
</body>
</html>
